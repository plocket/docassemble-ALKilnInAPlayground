---
comment: |
  alkiln-run --sources /my/dir/ --tags @1 and @2 --max_step_s 30
  https://docs.python.org/3/library/argparse.html#example
  alkiln-run --help would be useful for local devs
  env vars - don't want to change them a lot
  minimist - lib for parsing cli args?
  
  Current env var validation too simple. Maybe use _ORIGIN. Or validate where they're used. `setup.js` `session_vars.validate_setup_vars()`
---
comment: |
  TODO:
  See issue https://github.com/SuffolkLITLab/ALKiln/issues/675
---
features:
  css: alkiln_through_interview.css
---
mandatory: True
code: |
  if not user_logged_in():
    ask_to_log_in
  
  if version_error == '':
    if ask_version and wants_install:
      # Don't install if not needed
      if version_to_install != get_installed_version():
        alkiln_installation_output
        # `.wait()` could cause a timeout
        if alkiln_installation_output.ready():
          if alkiln_installation_output.failed():
            flag_failed_installation
        else:
          wait_for_install
  
  not_wants_tags
  tag_expression
  
  test_run_output
  if stopped_early or test_run_output.ready():
    run_get_files_html
    remove_tmp_files
    show_output
  else:
    waiting_screen
---
code: |
  test_run_output = background_action('run_alkiln', None, tag_expression=tag_expression, project_name=project_name)
---
event: stop_tests_early
code: |
  stopped_early = True
  test_run_output.revoke()
---
code: |
  stopped_early = False
---
code: |
  has_run_tests = False
---
event: run_alkiln
code: |
  import subprocess
  import os
  
  # if statement for idempotency - ensure tests are only run once
  if not has_run_tests:
    test_output = subprocess.run(
      ['/var/www/.npm-global/bin/alkiln-run'],
      check=False,
      capture_output=True,
      env=dict(os.environ,
        SERVER_URL=f'{url_of("root", _external=True)}',
        _ORIGIN='interview',
        _PROJECT_NAME=action_argument('project_name'),
        _USER_ID=f'{user_info().id}',
        _TAGS=action_argument('tag_expression'),
        # Don't need the values of these when running in interview
        REPO_URL="X",
        BRANCH_NAME="X",
        DOCASSEMBLE_DEVELOPER_API_KEY="X"
    ))
    has_run_tests = True
  
  # https://github.com/SuffolkLITLab/docassemble-AssemblyLine/blob/main/docassemble/AssemblyLine/al_document.py#L1275-L1284
  # https://github.com/SuffolkLITLab/docassemble-ALDashboard/blob/main/docassemble/ALDashboard/data/questions/compile_bootstrap.yml
  
  output = '<div class="console_output">\n'
  output += '<div class="section">\n'
  output += '<h2 id="report">Console output</h2>\n'
  output += '<pre>\n<code>\n'
  output += f'{test_output.stdout.decode("utf-8")}{test_output.stderr.decode("utf-8")}\n'
  output += '</code>\n</pre>\n'
  output += '</div>\n'
  output += '</div>\n'
  
  background_response(output)
---
code: |
  alkiln_installation_output = background_action('install_alkiln', None, version=version_to_install)
---
event: install_alkiln
code: |
  import subprocess
  import os
  
  subprocess.run(['mkdir', '-p', '/var/www/.npm-global'])
  
  # Must install with npm version, not GitHub branch as
  # we don't know a simple way to get the npm version from the
  # branch installation so we can help the user install the
  # right version or, alternatively, avoid installing anything
  # unecessary. On GitHub, though, we hope to use the branch
  # or commit as the source of truth for our version. This
  # unfortunately means there can't be just one source of truth
  # for which version of ALKiln is being used.
  
  if not did_install:
    to_install = f'@suffolklitlab/alkiln@{action_argument("version")}'
    install_output = subprocess.run(['npm', 'install', '-g', to_install], check=False, capture_output=True, env=dict(os.environ, NPM_CONFIG_PREFIX="/var/www/.npm-global"))
    did_install = True

  if install_output.returncode != 0:
    result = install_output.stderr.decode('utf-8')
    log('=== ALKiln === Error: installation failed:')
    log(result)
    # Cause error
    install_output.check_returncode()
  else:
    result = install_output.stdout.decode('utf-8')
    log('=== ALKiln === Installation succeeded:')
    log(result)

  background_response(result)
---
code: |
  did_install = False
---
code: |
  install_failed = True
  flag_failed_installation = True
---
code: |
  install_failed = False
---
code: |
  folder_name = get_folder_name()
  files_html = get_files_html(folder_name)
  if files_html == None:
    file_problem = True
  run_get_files_html = True
---
# Does this absolutely need to be separate? Do we at times
# want to avoid calling get_files_html()?
code: |
  file_problem = False
---
code: |
  if file_problem or stopped_early:
    no_output = True
  else:
    no_output = False
---
code: |
  import os
  import subprocess
  
  def get_files_html(folder_name):
    '''Return html to show files in the artifacts folder.
       Syntax highlighting.'''
    
    folder_exists = os.path.exists(f'/tmp/{folder_name}')
    if not folder_exists:
      return None
    
    html = ''
    
    safe_zip_name = get_zip_name(folder_name)
    zip_process = subprocess.run(['zip', '-r', f'{safe_zip_name}', f'{folder_name}'], cwd="/tmp", check=False, capture_output=True)
    if zip_process.returncode != 0:
      log('=== ALKiln === Error zipping artifacts folder:')
      log(zip_process.stderr.decode("utf-8"))
    else:
      zip_da_file = DAFile()
      zip_da_file.initialize(filename=f'{safe_zip_name}.zip')
      zip_da_file.copy_into(f'/tmp/{safe_zip_name}.zip')
      zip_da_file.commit()
    
      # Zip section
      html += '<div class="section zip">\n'
      html += f'{ action_button_html(zip_da_file.url_for(), label="Download all test files and folders", color="primary", size="md", icon="file-zipper", new_window=True, classname="zip") }\n'
      html += '</div>\n'
    
    # Start top-level output section
    html += '<div class="section top_level">\n'
    html += '<h2>Summary files</h2>\n'
    html += '<div class="output card card-body">\n'
    
    # collect top-level names and paths.
    top_dirs = []
    top_files = []
    
    # A bit faster than other methods, though that doesn't matter much here so far. https://stackoverflow.com/a/62478211/14144258
    with os.scandir(f'/tmp/{folder_name}') as scan:
      for dir_item in scan:
        if dir_item.is_file():
          top_files.append(dir_item)
        elif dir_item.is_dir():
          top_dirs.append(dir_item)
    
    # Show files that are for the all the tests combined
    # This includes error screenshots
    top_images_html = ''
    top_other_files_html = ''
    report_html = ''
    top_files.sort(key=lambda file: file.name)
    for file in top_files:
    
      file_html = get_file_html(name=file.name, path=file.path)
      
      if file.name.endswith('.jpg'):
        top_images_html += file_html
      else:
        if file.name == 'report.txt':
          report_html = file_html
        else:
          top_other_files_html += file_html
    
    # At least report and debug log
    html += f'<ul class="text_files">\n{report_html}\n{top_other_files_html}\n</ul>\n'
    if top_images_html != '':
      html += '<hr>\n'
      html += f'<ul class="images">\n{top_images_html}\n</ul>\n'
    
    # End top-level output contents
    html += '</div>\n'
    # End top-level output section
    html += '</div>\n'
    
    # Start all Scenarios
    html += '<div class="section scenarios">\n'
    
    # Show files in each Scenario
    top_dirs.sort(key=lambda dir: dir.name)
    html += '<h2>Scenario files</h2>\n'
    
    # For each Scenario
    for dir in top_dirs:
      
      html += '<div class="output card card-body scenario">\n'
      html += f'<h3>Scenario: {dir.name}</h3>\n'
      
      # Get the files in that Scenario
      for root_path, dir_names, file_names in os.walk(f'{dir.path}'):
        file_names.sort()
        
        # TODO: organize files by type: report, error, screenshots, downloaded. Maybe by timestamp instead of by name?
        
        text_files_html = ''
        images_html = ''
        templates_html = ''
        other_files_html = ''
        
        for file_name in file_names:
          abs_path = os.path.abspath(os.path.join(root_path, file_name))
          file_html = get_file_html(name=file_name, path=abs_path)
          
          if file_name.endswith('.txt'):
            text_files_html += file_html
          elif file_name.endswith('.jpg'):
            # TODO: separate error image from screenshots
            images_html += file_html
          elif file_name.endswith('.pdf') or file_name.endswith('.docx'):
            # TODO: need more flexibility for any downloaded files
            templates_html += file_html
          else:
            # Not sure what these'll be
            other_files_html += file_html
        
        if len(file_names) == 0:
          html += '<div class="no_files">No files.</div>'
        
        if text_files_html != '':
          html += f'<ul class="text_files">\n{text_files_html}\n</ul>\n'
        # Downloaded pdfs and docxs
        if templates_html != '':
          html += '<hr>\n'
          html += f'<ul class="templates">\n{templates_html}\n</ul>\n'
        if images_html != '':
          html += '<hr>\n'
          # Ordered list because timing creates an order that does matter. Moreso once we have story table screenshots
          html += f'<ol class="images">\n{images_html}\n</ol>\n'
        if other_files_html != '':
          html += '<hr>\n'
          html += f'<ul class="other_files">\n{other_files_html}\n</ul>\n'
      # End one Scenario
      html += '</div>\n'
      
    # End all Scenarios
    html += '</div>\n'
    
    return html
---
code: |
  def get_file_html(name='', path=''):
    # Show a DAFile for each file
    da_file = DAFile()
    da_file.initialize(filename=f'{name}')
    da_file.copy_into(f'{path}')
    da_file.commit()
    
    if name.endswith('.txt'):
      html = f'<li>\n{name} (<a target="_blank" href="{da_file.url_for()}">tap to see raw text <i class="fas fa-external-link"></i></a>)\n</li>\n'
    else:
      da_file.set_alt_text(f'The image for {name}.')
      html = f'<li class="image">\n<span>{name} (<a target="_blank" href="{da_file.url_for()}">tap to see file <i class="fas fa-external-link"></i></a>)</span>\n<div><a target="_blank" href="{da_file.url_for()}">{da_file}</a></div>\n</li>\n'
    
    return html
---
code: |
  import os
  
  safe_zip_name = get_zip_name(folder_name)
  try:
    os.remove(f'/tmp/{safe_zip_name}.zip')
  except Exception as error:
    log('=== ALKiln === Error removing ZIP:')
    log(error)
  
  import shutil
  try:
    shutil.rmtree(f'/tmp/{folder_name}')
  except Exception as error:
    log('=== ALKiln === Error removing FOLDER:')
    log(error)
  
  # https://stackoverflow.com/a/32949415/14144258
  import glob
  
  # Remove leftover puppeteer stuff if it exists (e.g. if they stopped the tests early)
  # https://github.com/puppeteer/puppeteer/issues/6414
  sub_folders_list = glob.glob('tmp/puppeteer_dev_chrome_profile*')
  for sub_folder in sub_folders_list:
      shutil.rmtree(sub_folder)
  
  remove_tmp_files = True
---
code: |
  import re
  
  def get_zip_name(folder_name):
    return re.sub("( )+", "_", folder_name)
---
code: |
  import json
  
  def get_folder_name():
    with open('/tmp/runtime_config.json') as config:
      folder_name = json.load(config)['artifacts_path']
    return folder_name
---
code: |
  from docassemble.webapp.files import SavedFile
  from docassemble.webapp.backend import directory_for
  import os

  def get_list_of_projects(user_id):
    playground = SavedFile(user_id, fix=False, section='playground')
    return playground.list_of_dirs()
  
---
event: ask_to_log_in
id: not logged in
question: |
  You need to log in
subquestion: |
  To run these tests, you need to be logged into the server where you're keeping the package that you will test.
  
  When you've logged in, come back and refresh.
buttons:
  Log into this server: signin
---
code: |
  import subprocess
  import json
  
  # all versions: https://stackoverflow.com/a/41416032/14144258
  # @>4.0.0 Also seems to get 3.0.9 for some reason
  result = subprocess.run(['npm', 'view', "@suffolklitlab/alkiln@>4.0.0", 'versions', '--json'], check=False, capture_output=True)
  if result.returncode != 0:
    log('=== ALKiln === Error getting ALKiln versions:')
    log(result.stderr.decode("utf-8"))
    alkiln_version_list = []
    version_error = result.stderr.decode("utf-8")
  else:
    alkiln_flip_order = json.loads(result.stdout.decode())[0]
    alkiln_flip_order.reverse()
    alkiln_version_list = alkiln_flip_order
    version_error = ''
---
code: |
  import subprocess
  import re
  
  def get_installed_version():
    '''Returns string to print for the version number.
       Can be some kind of error message. '''
    # https://stackoverflow.com/a/13332300
    packages = subprocess.run(['npm', 'list', '-g', '--prefix', '/var/www/.npm-global', '--depth', '0', '-p', '-l'], check=False, capture_output=True)
    # What would cause an error here?
    if result.returncode != 0:
      log('=== ALKiln === Error getting server ALKiln version:')
      log(packages.stderr.decode("utf-8"))
      server_version = 'Error getting server ALKiln version'
    else:
      pattern = re.compile(r'suffolklitlab/alkiln@(\d.*)$')
      matches = re.search(pattern, packages.stdout.decode())
      if matches == None:
        server_version = 'Could not find a version of ALKiln on the server. You need to install a version of ALKiln.'
      else:
        server_version = matches.group(1)
        del matches # cannot pickle error otherwise
    return server_version
---
id: which task with no alkiln installed
if: |
  'Could not find' in get_installed_version()
question: |
  Install ALKiln
subquestion: |
  It looks like you're running ALKiln tests for the first time on this server. Which version of ALKiln do you want to install? The top choice is the most recent version.
fields:
  - ALKiln version: version_to_install
    choices:
      code: |
        alkiln_version_list
continue button field: ask_version
---
id: which task with prexisting version
if: |
  not 'Could not find' in get_installed_version()
question: |
  ALKiln version
subquestion: |
  The server's current version of ALKiln is:[BR]
  **${ get_installed_version() }**
  
  Do you want to install a different version of ALKiln before testing?
fields:
  - Install a different verison of ALKiln: wants_install
    datatype: yesno
  - ALKiln version: version_to_install
    show if: wants_install
    choices:
      code: |
        alkiln_version_list
continue button field: ask_version
---
code: |
  wants_install = False
---
code: |
  install_start = current_datetime()
---
id: wait for alkiln install
prevent going back: True
reload: True
event: wait_for_install
question: |
  One sec, installing ALKiln v${version_to_install}
subquestion: |
  **Elapsed time: ${ str(date_difference( ending=current_datetime(), starting=install_start ).delta) }** (Updates every 10 seconds)
---
id: test info
question: |
  Run ALKiln tests
subquestion: |
  % if install_failed:
  <p class="alert alert-warning">
  Warning: ALKiln installation failed. You can still run your tests with the previous version you had installed. To see more, check <a target="_blank" href="${url_of('root', _external=True)}/logs?file=worker.log">your worker.log</a>. It might have been a problem with the node package manager (npm) servers. The <a href="https://status.npmjs.org/">npm status page</a> might tell you if npm servers are down. If you want to use a different version of ALKiln, you'll have to try again later.
  </p>
  % endif

  % if version_error != '':
  <p class="alert alert-warning">
  Warning: Usually you would have seen an option to install a different version of ALKiln. We skipped that screen because there was a problem getting information from the npm servers. You can check the output of the error in <a target="_blank" href="${url_of('root', _external=True)}/logs?file=docassemble.log">your docassemble.log</a>. It might have been a problem with the node package manager (npm) servers. The <a href="https://status.npmjs.org/">npm status page</a> might tell you if npm servers are down. If you want to use a different version of ALKiln, you'll have to try again later.
  </p>
  % endif
  
  You will run your tests with this version of ALKiln:[BR]
  ** ${ get_installed_version() }**
fields:
  - note: |
      The code you want to test should be in a Project on your Playground on this server.
  - What Project is the code in?: project_name
    input type: radio
    choices:
      code: |
        [[ proj, proj ] for proj in get_list_of_projects( user_info().id )]
  - note: |
      You can choose to run just specific tests using [tags](https://cucumber.io/docs/cucumber/api/?lang=java#tags) in your test file and putting a [tag expression](https://cucumber.io/docs/cucumber/api/#tag-expressions) here.
  - I want to run all the tests: not_wants_tags
    datatype: yesno
  - What tags do you want to use?: tag_expression
    hide if: not_wants_tags
    # Doesn't matter if they leave it blank
    required: False
continue button label: '<i class="far fa-play-circle"></i> Run tests'
#+ [['', 'Default']]
---
if:
  - not_wants_tags
code: |
  tag_expression = ''
---
code: |
  test_start_time = current_datetime()
---
reconsider: True
code: |
  # Deliberately explicit about the end time
  test_time = date_difference( ending=current_datetime(), starting=test_start_time )
---
prevent going back: True
event: waiting_screen
reload: True
question: |
  Hang tight. ALKiln is running the tests.
subquestion: |
  This screen will reload every 10 seconds until the tests are done.
  
  **Elapsed time: ${ str(test_time.delta) }** (Updates every 10 seconds)
  
action buttons:
  - label: Stop tests early
    action: stop_tests_early
    icon: window-close
    color: danger
---
prevent going back: True
event: show_output
question: |
  ALKiln output
subquestion: |

  <div id="alkiln_test_output">
  
  % if stopped_early:
  <p class="alert alert-warning">
  Warning: You stopped the tests early. Below is the information the tests collected so far.
  </p>
  % endif
  
  <div class="section">
  
  <div class="version">
  Ran with version <b>${ get_installed_version() }</b>.
  </div>
  <div class="elapsed_time">
  Elapsed time: <b>${ str(date_difference( ending=current_datetime(), starting=test_start_time ).delta) }</b>
  </div>
  % if not no_output:
  <div class="to_console">
  <a href="#report">Tap to see full console printout below</a>
  </div>
  % endif
  
  </div>
  
  % if file_problem:
  <p class="alert alert-danger">
  The installed version of ALKiln did not create any output which means the tests did not run. Your <a target="_blank" href="${url_of('root', _external=True)}/logs?file=worker.log"> worker.log</a> or your <a target="_blank" href="${url_of('root', _external=True)}/logs?file=docassemble.log">docassemble.log</a> might have more information.
  </p>
  % else:
  ${ files_html }
  % endif
  
  % if not no_output:
  ${ test_run_output.get() }
  % endif
  
  </div>

buttons:
  - Run new tests: new_session
---