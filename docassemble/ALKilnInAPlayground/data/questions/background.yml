---
comment: |
  TODO:
  - [ ] Add project name env var. #513 PR.
  - [ ] test using default project
  - [ ] restart this session
  - [ ] start new session/interview
  - [ ] delete generated files
  - [x] Use dynamic server url
  - [x] Use dynamic project
  - [x] Use dynamic user id
  - [x] Use dynamic tags
  
  the_task.revoke() will terminate the task. If you only want to remove the task from the queue if it has not started running yet, you can set the optional keyword argument terminate to False.
---
mandatory: True
code: |
  #if not user_logged_in():
  #  ask_to_log_in
  #wants_tags
  
  #test for stackoverflow question
  #if stackoverflow:
  #  undefine('stackoverflow')
  #  force_ask('waiting_screen')
  
  # Try to get timer going
  #time_passed
  #waiting_screen
  
  wants_tags
  #test_start_time
  the_task
  #if the_task.wait():  # Will cause a timeout
  if the_task.ready():  # Won't cause a timeout
    show_output
    #if do_delete:
    #  delete_task
    #  if delete_task.ready():
    #    deleted
    #  else:
    #    wait_for_delete
    pass
  else:
    waiting_screen
---
event: do_delete
code: |
  delete_task
  if delete_task.ready():
    deleted
  else:
    wait_for_delete
  finish_delete_artifacts_flow = True
---
id: stackoverflow
question: |
  Stackoverflow question
fields:
  - What file do you run to start the interview you want to test?: stackoverflow
---
code: |
  the_task = background_action('bg_task')
---
code: |
  delete_task = background_action('delete_artifacts')
---
code: |
  has_run_tests = False
---
event: bg_task
needs:
  - has_run_tests
  - get_folder_name
  - get_zip_name
  - got_files_html
  - get_files_html
code: |
  import subprocess
  import os
  import json
  import re
  
  if False:
    subprocess.run(['mkdir', '-p', '/var/www/.npm-global'])
  
  if False:
    installation = '<pre>\n<code>\n'
    installation += '<h2 style="font-size: 1.5em">Installing ALKiln</h2>\n\n'  # TODO: Add version number
    outcome = subprocess.run(['npm', 'install', '-g', 'github:SuffolkLITLab/ALKiln#cli_playground'], check=False, capture_output=True, env=dict(os.environ, NPM_CONFIG_PREFIX="/var/www/.npm-global"))
    if outcome.returncode != 0:
      installation += outcome.stderr.decode('utf-8')
    else:
      installation += outcome.stdout.decode('utf-8')
    installation += '</code>\n</pre>\n\n'
    installation += '---\n\n'
  else:
    installation = ""
  
  server_url = url_of('root', _external=True)
  
  # if statement for idempotency - ensure tests are only run once
  if not has_run_tests:
    test_output = subprocess.run(
      ['/var/www/.npm-global/bin/alkiln-run'],
      check=False,
      capture_output=True,
      env=dict(os.environ,
        _ORIGIN='interview',
        SERVER_URL=server_url,
        _PROJECT_NAME=project_name,
        _USER_ID=f'{user_info().id}',
        _TAGS=tag_expression,
        # Don't need the values of these when running in interview
        REPO_URL="X",
        BRANCH_NAME="X",
        DOCASSEMBLE_DEVELOPER_API_KEY="X"
    ))
    has_run_tests = True
  
  # https://github.com/SuffolkLITLab/docassemble-AssemblyLine/blob/main/docassemble/AssemblyLine/al_document.py#L1275-L1284
  # https://github.com/SuffolkLITLab/docassemble-ALDashboard/blob/main/docassemble/ALDashboard/data/questions/compile_bootstrap.yml
  
  folder_name = get_folder_name()
  safe_zip_name = get_zip_name(folder_name)
  contents = subprocess.run(['zip', '-r', safe_zip_name, folder_name], check=False, capture_output=True)
  
  # This logs and is happy. When I abstract this elsewhere, it doesn't log.
  zip_file = DAFile()
  zip_file.initialize(filename=f'{safe_zip_name}.zip')
  zip_file.copy_into(f'{safe_zip_name}.zip')
  zip_file.commit()
  
  if (not got_files_html):
    files_html = get_files_html(folder_name)
    got_files_html = True
  
  output = f'<a href=\'{zip_file.url_for()}\'><i class="fa-solid fa-file-zipper"></i> <span>Download all test files</span></a>\n\n'
  output += f'{files_html}\n\n'
  output += installation
  output += '<h2 style="font-size=1.5em;">Test report</h2>\n\n'
  output += '<pre>\n<code>\n'
  output += f'{test_output.stdout.decode("utf-8")}{test_output.stderr.decode("utf-8")}\n'
  output += '</code>\n</pre>\n\n'
  output += f'{ action_button_html(url_action("do_delete"), label="Delete generated files") }'
  
  background_response(output) #.stdout.decode('utf-8').strip())
---
code: |
  got_files_html = False
---
code: |
  import os
  
  def sort_by_name(item):
    pass
  
  def get_files_html(folder_name):
    '''Return html to show files in the artifacts folder.
        Syntax highlighting.'''
    html = '<div>\n'
    html += '<h2 style="font-size: 1.2em">Files for all tests</h2>\n'
    html += '<ul>\n'
    
    # Not recursive
    #for dirs_and_file_names in os.listdir(f'/tmp/{folder_name}'):
    #  html += f'<li>\n{dir}\n</li>\n'
    
    # Not recursive
    top_dirs = []
    top_files = []
    
    # collect names and paths
    with os.scandir(f'/tmp/{folder_name}') as scan:
      for dir_item in scan:
        if dir_item.is_file():
          top_files.append(dir_item)
        elif dir_item.is_dir():
          top_dirs.append(dir_item)
    
    # Show files that are for the all the tests combined
    # This includes error screenshots
    # TODO: alkiln, when there are secrets on a page, show something in place of an error screenshot. Default image?
    top_files.sort(key=lambda file: file.name)
    for file in top_files:
      html += get_file_html(name=file.name, path=file.path)
    
    # Show files in each Scenario
    top_dirs.sort(key=lambda dir: dir.name)
    html += '</ul>\n'
    html += '<h2 style="font-size: 1.5em">Files for Scenarios</h2>\n'
    html += '<ul>\n'
    for dir in top_dirs:
      html += '<li>\n'
      html += f'<i class="fas fa-folder"></i> <h3 style="font-size: 1.2em">{dir.name}</h3><span>: {dir.path}</span>\n'
      html += '<ul>\n'
      for root_path, dir_names, file_names in os.walk(f'{dir.path}'):
        file_names.sort()
        for file_name in file_names:
          abs_path = os.path.abspath(os.path.join(root_path, file_name))
          html += get_file_html(name=file_name, path=abs_path)
      html += '</ul>\n'
      html += '</li>\n'
      
    html += '</ul></div>'
    
    return html
---
code: |
  def get_file_html(name='', path=''):
    # Show a DAFile for each file
    da_file = DAFile()
    da_file.initialize(filename=f'{name}')
    log(f'5: {path}')
    #abs_file_path = os.path.abspath(os.path.join(path))
    da_file.copy_into(f'{path}')
    da_file.commit()
    log(f'6: {da_file.url_for()}')

    html = ''
    if name.endswith('.txt'):
      html += f'<li>\n{name} (<a target="_blank" href="{da_file.url_for()}">See raw text</a>)\n</li>\n'
    else:
      html += f'<li>\n<span>{name}:</span>\n<div><a target="_blank" href="{da_file.url_for()}">{da_file}</a></div>\n</li>\n'
    
    return html
---
event: delete_artifacts
code: |
  folder_name = get_folder_name()
  safe_zip_name = get_zip_name(folder_name)
  
  import os
  try:
    os.remove(f'/tmp/{safe_zip_name}.zip')
  except Exception as error:
    log('removing ZIP error:')
    log(error)
  
  import shutil
  try:
    shutil.rmtree(f'/tmp/{folder_name}')
  except Exception as error:
    log('removing FOLDER error:')
    log(error)
  
  background_response('deleted')
---
code: |
  import re
  
  def get_zip_name(folder_name):
    return re.sub("( )+", "_", folder_name)
---
code: |
  import json
  
  def get_folder_name():
    with open('/tmp/runtime_config.json') as config:
      folder_name = json.load(config)['artifacts_path']
    return folder_name
---
code: |
  from docassemble.webapp.files import SavedFile
  from docassemble.webapp.backend import directory_for
  import os

  def get_list_of_projects(user_id):
    playground = SavedFile(user_id, fix=False, section='playground')
    return playground.list_of_dirs()
    
  #def get_project_file_paths(user_id, section='playground', project='default'):
  #  area = SavedFile(user_id, fix=True, section=section)
  #  the_directory = directory_for(area, project)
  #  files = [os.path.join(the_directory, file) for file in os.listdir(the_directory) if os.path.isfile(os.path.join(the_directory, file))]
  #  # Maybe remove the `.placeholder` file, here or later
  #  return files
---
event: ask_to_log_in
id: not logged in
question: |
  You need to log in
subquestion: |
  To run these tests, you need to be logged into the server where you're keeping the package that you will test.
  
  When you've logged in, come back and refresh.
---
id: test info
comment: |  
  ${ user_info().id }
  
  ${ get_list_of_projects( user_info().id ) }
  
  ${ user_info().package }
  
  ${ user_info().filename }
question: |
  How much shall I add to 553?
subquestion: |
  Not spinning: <i class="fas fa-spinner fa-spin"></i>
  
fields:
  - Do you want to use tags?: wants_tags
    datatype: yesnoradio
  - What tags do you want to use? Use a tag expression: tag_expression
    show if: wants_tags
  - note: |
      The code you want to test should be in a Project on your Playground
  - What Project is the code in?: project_name
    input type: radio
    choices:
      code: |
        [[ proj, proj ] for proj in get_list_of_projects( user_info().id )]
#+ [['', 'Default']]
---
if:
  - not wants_tags
code: |
  tag_expression = ''
---
code: |
  test_start_time = current_datetime()
---
reconsider: True
code: |
  # Deliberately explicit about the end time
  test_time = date_difference( ending=current_datetime(), starting=test_start_time )
---
prevent going back: True
event: waiting_screen
reload: True
question: |
  Hang tight. Still waiting for an answer.
subquestion: |
  This screen will reload every ten seconds until the answer is available.
  
  <i class="fas fa-spinner fa-spin"></i>
  
  Elapsed time: ${ str(test_time.delta) } (Will refresh every 10 seconds)
#  :${ test_time.seconds } 
  
#  ${ format_time(date_difference( ending=current_datetime(), starting=test_start_time ), format='hh:mm:ss') } since the tests started
  
# experiment for stack overflow question
#back button: True
#buttons:
#  - Back: refresh
#  - Exit: exit
#    url: https://ecosia.com
---
prevent going back: True
event: show_output
question: |
  The answer is
subquestion: |
  
  ${ the_task.get() }
  
#fields:
#  - Delete generated files and folders: do_delete
#    datatype: yesnoradio
---
code: |
  delete_start_time = current_datetime()
---
reconsider: True
code: |
  # Deliberately explicit about the end time
  delete_time = date_difference( ending=current_datetime(), starting=test_start_time )
---
prevent going back: True
id: wait for delete
event: wait_for_delete
reload: True
question: |
  Still deleting files and folders
subquestion: |
  Elapsed time: ${ str(delete_time.delta) } (Will refresh every 10 seconds)
---
prevent going back: True
id: deleted
event: deleted
question: |
  Cleaned up
subquestion: |
  Deleted all files and folders generated by ALKiln.
---