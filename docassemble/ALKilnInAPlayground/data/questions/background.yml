---
comment: |
  alkiln-run --sources /my/dir/ --tags @1 and @2 --max_step_s 30
  https://docs.python.org/3/library/argparse.html#example
  alkiln-run --help
  env vars don't want to change them a lot
  minimist
  
  Current env var validation too simple. Maybe use _ORIGIN. Or validate where they're used. `setup.js` `session_vars.validate_setup_vars()`
---
comment: |
  TODO:
  - [ ] Choose version of ALKiln with cached version
  - [ ] Allow user to stop in the middle of the test and jump straight to output. See new `revoke`
  - [ ] Clean up files no matter what
  - [ ] Add project name env var. #513 PR.
  - [ ] test using default project
  - [ ] restart this session
  - [ ] start new session/interview
  - [ ] Bug: deleting goes back to output page before going to end
  - [ ] Coloring output: Cucumber formatter for some of it maybe https://github.com/cucumber/cucumber-js/blob/main/docs/formatters.md
  - [ ] Style results page. Scenario background color?
  - [ ] Set other env vars (like max time per step)

  DONE:
  - [x] Delete /tmp files after copying into da files (doesn't keep the folder structure, but I guess the zip does)
  - [x] Use dynamic server url
  - [x] Use dynamic project
  - [x] Use dynamic user id
  - [x] Use dynamic tags
  
  test_run_output.revoke() will terminate the task. If you only want to remove the task from the queue if it has not started running yet, you can set the optional keyword argument terminate to False.
---
features:
  css: alkiln_through_interview.css
---
mandatory: True
code: |
  #if not user_logged_in():
  #  ask_to_log_in
  not_wants_tags
  tag_expression
  # Get stopwatch going
  test_start_time
  test_run_output
  # `.wait()` WILL cause a timeout
  if stopped_early \
      or test_run_output.ready():  # Won't cause a timeout
    run_get_files_html
    remove_tmp_files
    show_output
  else:
    waiting_screen
---
event: stop_tests_early
code: |
  stopped_early = True
  test_run_output.revoke()
---
code: |
  stopped_early = False
---
code: |
  test_run_output = background_action('run_alkiln', None, tag_expression=tag_expression, project_name=project_name)
---
code: |
  has_run_tests = False
---
code: |
  has_installed_alkiln = False
---
code: |
  got_files_html = False
---
event: run_alkiln
needs:
  - has_run_tests
  - get_folder_name
  - get_zip_name
  - got_files_html
  - get_files_html
code: |
  import subprocess
  import os
  import json
  import re
  
  if False:
    subprocess.run(['mkdir', '-p', '/var/www/.npm-global'])
  
  if False and not has_installed_alkiln:
    
    # TODO: Add version number here
    installation = '<h2>Installing ALKiln</h2>\n'  # TODO: Add version number
    installation += '<div class="section"><pre>\n<code>\n'
    # Get current version (or commit sha if want to be consistent with GitHub and use one source of truth) (maybe can't get commit sha from npm installed version if we install from a branch)
    # TODO: (maybe) Get git commit, detect git commit npm version, install npm version. SO MUCH MORE WORK.
    # But then we need (for users) a place where we're listing commit sha's and their respective npm versions or a pointer to how to look that up. So people can use the same version everywhere they're running it.
    # Problem: on GitHub users will be using the commit sha to specifiy the version of ALKiln to use. When they come to this interview, how will they know what to set to make sure they're using the same version here?
    # * Save the git commit elsewhere when they input it.
    # Should we let them install via npm version optionally instead?
    # Avoiding npm version makes it much harder to update packages to new versions. So we won't have one source of truth.
    # TODO: Document this weird behavior somewhere. Maybe an 'advanced' page of the documentation.
    
    # Store the input of the version somewhere on their server
    # What file? txt file?
    # Also, what if they want to install `latest`? How do we check that a version is up to date?
    # https://stackoverflow.com/questions/11949419/npm-how-to-show-the-latest-version-of-a-package
    
    # Have to at least report the version
    outcome = subprocess.run(['npm', 'install', '-g', 'github:SuffolkLITLab/ALKiln#cli_playground'], check=False, capture_output=True, env=dict(os.environ, NPM_CONFIG_PREFIX="/var/www/.npm-global"))
    if outcome.returncode != 0:
      installation += outcome.stderr.decode('utf-8')
    else:
      installation += outcome.stdout.decode('utf-8')
    installation += '</code>\n</pre></div>\n'
    installation += '---\n\n'
    has_installed_alkiln = True
  else:
    installation = ""
  
  server_url = url_of('root', _external=True)
  
  # if statement for idempotency - ensure tests are only run once
  if not has_run_tests:
    test_output = subprocess.run(
      ['/var/www/.npm-global/bin/alkiln-run'],
      check=False,
      capture_output=True,
      env=dict(os.environ,
        SERVER_URL=server_url,
        _ORIGIN='interview',
        _PROJECT_NAME=project_name,
        _USER_ID=f'{user_info().id}',
        _TAGS=tag_expression,
        # Don't need the values of these when running in interview
        REPO_URL="X",
        BRANCH_NAME="X",
        DOCASSEMBLE_DEVELOPER_API_KEY="X"
    ))
    has_run_tests = True
  
  # https://github.com/SuffolkLITLab/docassemble-AssemblyLine/blob/main/docassemble/AssemblyLine/al_document.py#L1275-L1284
  # https://github.com/SuffolkLITLab/docassemble-ALDashboard/blob/main/docassemble/ALDashboard/data/questions/compile_bootstrap.yml
  
  log('=================== finished run')
  
  output = '<div class="console_output">\n'
  output += installation
  output += '<div class="section">\n'
  output += '<h2 id="report">Test report</h2>\n'
  output += '<pre>\n<code>\n'
  output += f'{test_output.stdout.decode("utf-8")}{test_output.stderr.decode("utf-8")}\n'
  output += '</code>\n</pre>\n'
  output += '</div>\n'
  output += '</div>\n'
  
  background_response(output)
---
code: |
  folder_name = get_folder_name()
  files_html = get_files_html(folder_name)
  run_get_files_html = True
---
code: |
  import os
  import subprocess
  
  def get_files_html(folder_name):
    '''Return html to show files in the artifacts folder.
       Syntax highlighting.'''
    
    html = ''
    
    safe_zip_name = get_zip_name(folder_name)
    ls = subprocess.run(['ls', '/tmp'], check=False, capture_output=True)
    zip_process = subprocess.run(['zip', '-r', f'/tmp/{safe_zip_name}', f'/tmp/{folder_name}'], check=False, capture_output=True)
    log(f'Zip creation error if any: ${zip_process.stderr.decode()}')
    zip_da_file = DAFile()
    zip_da_file.initialize(filename=f'{safe_zip_name}.zip')
    zip_da_file.copy_into(f'/tmp/{safe_zip_name}.zip')
    zip_da_file.commit()
    
    # Zip section
    html += '<div class="section zip">\n'
    html += f'{ action_button_html(zip_da_file.url_for(), label="Download all test files", color="primary", size="md", icon="file-zipper", new_window=True, classname="zip") }\n'
    html += '</div>\n'
    
    # Start top-level output section
    html += '<div class="section top_level">\n'
    html += '<h2>Output for all tests</h2>\n'
    html += '<div class="output card card-body">\n'
    
    # collect names and paths.
    top_dirs = []
    top_files = []
    
    # A bit faster than other methods, though that doesn't matter much. https://stackoverflow.com/a/62478211/14144258
    with os.scandir(f'/tmp/{folder_name}') as scan:
      for dir_item in scan:
        if dir_item.is_file():
          top_files.append(dir_item)
        elif dir_item.is_dir():
          top_dirs.append(dir_item)
    
    # Show files that are for the all the tests combined
    # This includes error screenshots
    # TODO: alkiln, when there are secrets on a page, show something in place of an error screenshot. Default image?
    top_images_html = ''
    top_other_files_html = ''
    top_files.sort(key=lambda file: file.name)
    for file in top_files:
      if file.name.endswith('.jpg'):
        top_images_html += get_file_html(name=file.name, path=file.path)
      else:
        top_other_files_html += get_file_html(name=file.name, path=file.path)
    
    # At least report and debug log
    html += f'<ul class="text_files">\n{top_other_files_html}\n</ul>\n'
    if top_images_html != '':
      html += '<hr>\n'
      html += f'<ul class="images">\n{top_images_html}\n</ul>\n'
    
    # End top-level output contents
    html += '</div>\n'
    # End top-level output section
    html += '</div>\n'
    
    # Start all Scenarios
    html += '<div class="section scenarios">\n'
    
    # Show files in each Scenario
    top_dirs.sort(key=lambda dir: dir.name)
    html += '<h2>Output for Scenarios</h2>\n'
    
    # For each Scenario
    for dir in top_dirs:
    
      html += '<div class="output card card-body scenario">\n'
      html += f'<h3>Scenario: {dir.name}</h3>\n'
      
      # Get the files in that Scenario
      for root_path, dir_names, file_names in os.walk(f'{dir.path}'):
        file_names.sort()
        
        # This is not really how we should organize them. Eventually
        # organize them by type: report, error, screenshots, downloaded
        # Maybe by timestamp instead of by name?
        
        text_files_html = ''
        images_html = ''
        templates_html = ''
        other_files_html = ''
        
        for file_name in file_names:
          abs_path = os.path.abspath(os.path.join(root_path, file_name))
          file_html = get_file_html(name=file_name, path=abs_path)
          
          if file_name.endswith('.txt'):
            text_files_html += file_html
          elif file_name.endswith('.jpg'):
            images_html += file_html
          elif file_name.endswith('.pdf') or file_name.endswith('.docx'):
            templates_html += file_html
          else:
            # Not sure what these'll be
            other_files_html += file_html
        
        # Text files come in a list first. Report will at least be there
        html += f'<ul class="text_files">\n{text_files_html}\n</ul>\n'
        # Downloaded pdfs and docxs come next (TODO: any downloaded files)
        if templates_html != '':
          html += '<hr>\n'
          html += f'<ul class="templates">\n{templates_html}\n</ul>\n'
        # Images come last (TODO: split any error image out)
        if images_html != '':
          html += '<hr>\n'
          # Ordered list because timing does matter a bit with these
          # Moreso once we have story table screenshots
          html += f'<ol class="images">\n{images_html}\n</ol>\n'
        if other_files_html != '':
          html += '<hr>\n'
          html += f'<ul class="other_files">\n{other_files_html}\n</ul>\n'
      # End one Scenario
      html += '</div>\n'
      
    # End all Scenarios
    html += '</div>\n'
    
    return html
---
code: |
  def get_file_html(name='', path=''):
    # Show a DAFile for each file
    da_file = DAFile()
    da_file.initialize(filename=f'{name}')
    #abs_file_path = os.path.abspath(os.path.join(path))
    da_file.copy_into(f'{path}')
    da_file.commit()
    
    if name.endswith('.txt'):
      html = f'<li>\n{name} (<a target="_blank" href="{da_file.url_for()}">tap to see raw text <i class="fas fa-external-link"></i></a>)\n</li>\n'
    else:
      da_file.set_alt_text(f'The image for {name}.')
      html = f'<li class="image">\n<span>{name} (<a target="_blank" href="{da_file.url_for()}">tap to see file <i class="fas fa-external-link"></i></a>)</span>\n<div><a target="_blank" href="{da_file.url_for()}">{da_file}</a></div>\n</li>\n'
    
    return html
---
code: |
  import os
  
  safe_zip_name = get_zip_name(folder_name)
  try:
    os.remove(f'/tmp/{safe_zip_name}.zip')
  except Exception as error:
    log('error removing ZIP:')
    log(error)
  
  import shutil
  try:
    shutil.rmtree(f'/tmp/{folder_name}')
  except Exception as error:
    log('error removing FOLDER:')
    log(error)
  
  remove_tmp_files = True
---
code: |
  import re
  
  def get_zip_name(folder_name):
    return re.sub("( )+", "_", folder_name)
---
code: |
  import json
  
  def get_folder_name():
    with open('/tmp/runtime_config.json') as config:
      folder_name = json.load(config)['artifacts_path']
    return folder_name
---
code: |
  from docassemble.webapp.files import SavedFile
  from docassemble.webapp.backend import directory_for
  import os

  def get_list_of_projects(user_id):
    playground = SavedFile(user_id, fix=False, section='playground')
    return playground.list_of_dirs()
    
  #def get_project_file_paths(user_id, section='playground', project='default'):
  #  area = SavedFile(user_id, fix=True, section=section)
  #  the_directory = directory_for(area, project)
  #  files = [os.path.join(the_directory, file) for file in os.listdir(the_directory) if os.path.isfile(os.path.join(the_directory, file))]
  #  # Maybe remove the `.placeholder` file, here or later
  #  return files
---
event: ask_to_log_in
id: not logged in
question: |
  You need to log in
subquestion: |
  To run these tests, you need to be logged into the server where you're keeping the package that you will test.
  
  When you've logged in, come back and refresh.
---
id: test info
question: |
  Run ALKiln tests
fields:
  - note: |
      You can choose to run just specific tests using [tags](https://cucumber.io/docs/cucumber/api/?lang=java#tags) in your test file and putting a [tag expression](https://cucumber.io/docs/cucumber/api/#tag-expressions) here.
  - I do NOT want to use tags: not_wants_tags
    datatype: yesno
  - What tags do you want to use?: tag_expression
    disable if: not_wants_tags
    # Doesn't matter if they leave it blank
    required: False
  - note: |
      The code you want to test should be in a Project on your Playground
  - What Project is the code in?: project_name
    input type: radio
    choices:
      code: |
        [[ proj, proj ] for proj in get_list_of_projects( user_info().id )]
#+ [['', 'Default']]
comment: |  
  ${ user_info().id }
  
  ${ get_list_of_projects( user_info().id ) }
  
  ${ user_info().package }
  
  ${ user_info().filename }
---
if:
  - not_wants_tags
code: |
  tag_expression = ''
---
code: |
  test_start_time = current_datetime()
---
reconsider: True
code: |
  # Deliberately explicit about the end time
  test_time = date_difference( ending=current_datetime(), starting=test_start_time )
---
prevent going back: True
event: waiting_screen
reload: True
question: |
  Hang tight. ALKiln is running the tests.
subquestion: |
  This screen will reload every 10 seconds until the tests are done.
  
  <i class="fas fa-spinner fa-spin"></i>
  
  **Elapsed time: ${ str(test_time.delta) }** (Refreshes every 10 seconds)
  
action buttons:
  - label: Stop tests early
    action: stop_tests_early
---
prevent going back: True
event: show_output
question: |
  ALKiln output
subquestion: |

  <div id="alkiln_test_output">
  
  <div class="section elapsed_time">
  Elapsed time: <b>${ str(date_difference( ending=current_datetime(), starting=test_start_time ).delta) }</b>
  </div>
  
  % if not stopped_early:
  <div class="section">
  <a href="#report">Tap to see full console printout below</a>
  </div>
  % endif
  
  ${ files_html }
  
  % if not stopped_early:
  ${ test_run_output.get() }
  % endif
  
  </div>

buttons:
  - Run new tests: new_session
---